# problema 1
#If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
# Find the sum of all the multiples of 3 or 5 below 1000.
i = 0
l=sapply(1:999,function(x){
  if (x%%3==0 | x%%5==0){i <<- i+ x;x} else{NA}
})
print(i)

# problem 2
#Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
#  
#  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
#
#By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

fibo = function(){
  l = 1:2
  while (last(l)<4e6){
    l = c(l,sum(last(l),l[length(l)-1]))
  }
  l[which(l%%2!=0)]=0
  sum(l[-c(1,length(l))])
  return(l)
}

# problem 3
# The prime factors of 13195 are 5, 7, 13 and 29.
# 
# What is the largest prime factor of the number 600851475143 ?

num = 600851475143
num=3*3*5*7*7
lgprime = function(num){
  x = 2
  u = 0
  a = 0
  while(a!=1){
    
   if( all(x%%(2:(x-1))!=0) & num%%x==0){u = x ; while(num%%u==0){num = num/u} ; if (num==1){a=1} else {x = x+1}} else {x = x + 1}
  }
  return(u)
}
lgprime(num)

# problem 4
#A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
#
#Find the largest palindrome made from the product of two 3-digit numbers
library(stringi)
n = 2
lrgpal = function(n){
  mx = as.numeric(strrep("9",n))
  m = rep(mx,2)
  sol=0
  for (i in seq(mx,100)){
    for (j in seq(mx,100)){
      if (as.character(i*j)==stri_reverse(i*j) & i*j>sol){sol=i*j;break}
    }
  }
  #while (a!=1){
  #  z = prod(m)
  #  if (as.character(z)==stri_reverse(z)){print(z);break}
  #  m[i%%2+1] = m[i%%2+1]-1
  #  i=i+1
  #}
  print(c(i,j,sol))
}

# problem 5
#2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
#
#What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

primes = c(2,3,5,7,13,17)
smmlt = function(n){
  z = n:2
  primes = primes[primes<n]
 aux=sapply(primes,function(x){
   i=z%%x==0
   s = z[i]
   k = which(s==x)
   while (length(which(unique(s)%%x==0))>1){
     s[s%%x==0] = s[s%%x==0]/x
     k=which(s%%x==0)
   }
   s[k[1]]=z[which(i)[k[1]]] ; if (length(k)>1) s[k[-1]]=s[k[-1]]/x
   z[i]<<-s
 })
 print(prod(z))
}

# problem 6
#The sum of the squares of the first ten natural numbers is,
#
#12 + 22 + ... + 102 = 385
#The square of the sum of the first ten natural numbers is,
#
#(1 + 2 + ... + 10)2 = 552 = 3025
#Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 ??? 385 = 2640.
#
#Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.

-sum(sapply(1:100,function(x) x^2))+sum(1:100)^2

# problem 5
# Find the 10001st prime


prmfind = function(z){
  prm = c(2,3)
  x = 4
  y = 2
  while (length(prm)<z){
    
    while (any(x%%(y:(x-1))==0)){
      x=x+1
    }
    prm<-c(prm,x)
    x=x+1
  }
  return(prm)
}
library(tictoc)
tic()
prmfind(10003)
toc()

# problem 7
# find the 13 adjacent digits with highest product
num = "73167176531330624919225119674426574742355349194934
96983520312774506326239578318016984801869478851843
85861560789112949495459501737958331952853208805511
12540698747158523863050715693290963295227443043557
66896648950445244523161731856403098711121722383113
62229893423380308135336276614282806444486645238749
30358907296290491560440772390713810515859307960866
70172427121883998797908792274921901699720888093776
65727333001053367881220235421809751254540594752243
52584907711670556013604839586446706324415722155397
53697817977846174064955149290862569321978468622482
83972241375657056057490261407972968652414535100474
82166370484403199890008895243450658541227588666881
16427171479924442928230863465674813919123162824586
17866458359124566529476545682848912883142607690042
24219022671055626321111109370544217506941658960408
07198403850962455444362981230987879927244284909188
84580156166097919133875499200524063689912560717606
05886116467109405077541002256983155200055935729725
71636269561882670428252483600823257530420752963450"

adjprod = function(n){
  num = as.numeric(strsplit(num,"")[[1]])
  k = sapply(1:(length(num)-n+1),function(x) prod(num[x:(x+n-1)]))
  print(max(k,na.rm=TRUE))
}

# fibonacci with 1000 digits
library(dplyr)
fibon = function(n){
  fib = c(1,2)
  i=1
  #while(nchar(last(fib))<n){
  #  fib = c(fib,(last(fib)+rev(fib)[2]))
  #}
  while(i<n){
    fib=c(fib,(last(fib)+rev(fib)[2]))
    i=i+1
  }
  fib
}

# problem 10 sum all primes bellow 2M
library(dplyr)
prmfind = function(z){
  prm = c(2,3)
  x = 4
  y = 2
  while (last(prm)<z){
    
    while (any(x%%(y:(x-1))==0)){
      x=x+1
    }
    prm<-c(prm,x)
    x=x+1
  }
  return(prm)
}
z = prmfind(2000000)

n = 2
z = c("this is what it is and is not", "this is not", "this is it it is","is is is is")
c(FALSE,FALSE,TRUE)
grepl("(.*\\bis\\b.*){2}",z) & !grepl("(.*\\bis\\b.*){3}",z)

lengths(regmatches(z, gregexpr("\\bis\\b", z))) == 2

# prob 9
#A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
#
#a2 + b2 = c2
#For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
#
#There exists exactly one Pythagorean triplet for which a + b + c = 1000.
#Find the product abc.
for (a in 1:1000){
  for (b in 1:1000){
    for (c in 1:1000){
      if (a^2 + b^2 == c^2 & a + b + c == 1000){print(paste("a:",a,",b:",b,",c:",c))}
    }
  }
}

# prob 10
# largest number of prod(4)
db = c(        08, 02 ,22, 97, 38, 15, 00, 40, 00, 75, 04 ,05 ,07 ,78 ,52 ,12, 50, 77, 91, 08,
                49, 49 ,99, 40, 17, 81, 18, 57, 60, 87, 17 ,40 ,98 ,43 ,69 ,48, 04, 56, 62, 00,
                81, 49 ,31, 73, 55, 79, 14, 29, 93, 71, 40 ,67 ,53 ,88 ,30 ,03, 49, 13, 36, 65,
                52, 70 ,95, 23, 04, 60, 11, 42, 69, 24, 68 ,56 ,01 ,32 ,56 ,71, 37, 02, 36, 91,
                22, 31 ,16, 71, 51, 67, 63, 89, 41, 92, 36 ,54 ,22 ,40 ,40 ,28, 66, 33, 13, 80,
                24, 47 ,32, 60, 99, 03, 45, 02, 44, 75, 33 ,53 ,78 ,36 ,84 ,20, 35, 17, 12, 50,
                32, 98 ,81, 28, 64, 23, 67, 10, 26, 38, 40 ,67 ,59 ,54 ,70 ,66, 18, 38, 64, 70,
                67, 26 ,20, 68, 02, 62, 12, 20, 95, 63, 94 ,39 ,63 ,08 ,40 ,91, 66, 49, 94, 21,
                24, 55 ,58, 05, 66, 73, 99, 26, 97, 17, 78 ,78 ,96 ,83 ,14 ,88, 34, 89, 63, 72,
                21, 36 ,23, 09, 75, 00, 76, 44, 20, 45, 35 ,14 ,00 ,61 ,33 ,97, 34, 31, 33, 95,
                78, 17 ,53, 28, 22, 75, 31, 67, 15, 94, 03 ,80 ,04 ,62 ,16 ,14, 09, 53, 56, 92,
                16, 39 ,05, 42, 96, 35, 31, 47, 55, 58, 88 ,24 ,00 ,17 ,54 ,24, 36, 29, 85, 57,
                86, 56 ,00, 48, 35, 71, 89, 07, 05, 44, 44 ,37 ,44 ,60 ,21 ,58, 51, 54, 17, 58,
                19, 80 ,81, 68, 05, 94, 47, 69, 28, 73, 92 ,13 ,86 ,52 ,17 ,77, 04, 89, 55, 40,
                04, 52 ,08, 83, 97, 35, 99, 16, 07, 97, 57 ,32 ,16 ,26 ,26 ,79, 33, 27, 98, 66,
                88, 36 ,68, 87, 57, 62, 20, 72, 03, 46, 33 ,67 ,46 ,55 ,12 ,32, 63, 93, 53, 69,
                04, 42 ,16, 73, 38, 25, 39, 11, 24, 94, 72 ,18 ,08 ,46 ,29 ,32, 40, 62, 76, 36,
                20, 69 ,36, 41, 72, 30, 23, 88, 34, 62, 99 ,69 ,82 ,67 ,59 ,85, 74, 04, 36, 16,
                20, 73 ,35, 29, 78, 31, 90, 01, 74, 31, 49 ,71 ,48 ,86 ,81 ,16, 23, 57, 05, 54,
                01, 70 ,54, 71, 83, 51, 54, 69, 16, 92, 33 ,48 ,61 ,43 ,52 ,01, 89, 19, 67, 48)
dim(db)= c(20,20)
db = t(db)


gridf = function(n){
  mx = c(0,0,0)
  for (i in 1:(nrow(db))){
    for (j in 1:(ncol(db))){
      ix = (i+n-1)
      jx = (j+n-1)
      if (all(c(jx,ix)<=20)){
        r = prod(db[i:ix,j])
        b = prod(db[i,j:jx])
        d = prod(diag(db[i:ix,j:jx]))
        d2 = prod(diag(db[ix:i,jx:j]))
        if (any(c(r,d,b,d2)>mx[3])){mx=c(i,j,max(c(r,d,b,d2)))}
      }
    }
  }
  return(mx)

}

# triangle number 500 divisors

a = sum(1:1000000)
b=a%%(1:999999)
c=sapply(1:50,function(x) {b=sum(1:x);length(which(b%%(1:(b))==0))})


numbers2words <- function(x){
  ## Function by John Fox found here: 
  ## http://tolstoy.newcastle.edu.au/R/help/05/04/2715.html
  ## Tweaks by AJH to add commas and "and"
  helper <- function(x){
    
    digits <- rev(strsplit(as.character(x), "")[[1]])
    nDigits <- length(digits)
    if (nDigits == 1) as.vector(ones[digits])
    else if (nDigits == 2)
      if (x <= 19) as.vector(teens[digits[1]])
    else trim(paste(tens[digits[2]],
                    Recall(as.numeric(digits[1]))))
    else if (nDigits == 3) trim(paste(ones[digits[3]], "hundred and", 
                                      Recall(makeNumber(digits[2:1]))))
    else {
      nSuffix <- ((nDigits + 2) %/% 3) - 1
      if (nSuffix > length(suffixes)) stop(paste(x, "is too large!"))
      trim(paste(Recall(makeNumber(digits[
        nDigits:(3*nSuffix + 1)])),
        suffixes[nSuffix],"," ,
        Recall(makeNumber(digits[(3*nSuffix):1]))))
    }
  }
  trim <- function(text){
    #Tidy leading/trailing whitespace, space before comma
    text=gsub("^\ ", "", gsub("\ *$", "", gsub("\ ,",",",text)))
    #Clear any trailing " and"
    text=gsub(" and$","",text)
    #Clear any trailing comma
    gsub("\ *,$","",text)
  }  
  makeNumber <- function(...) as.numeric(paste(..., collapse=""))     
  #Disable scientific notation
  opts <- options(scipen=100) 
  on.exit(options(opts)) 
  ones <- c("", "one", "two", "three", "four", "five", "six", "seven",
            "eight", "nine") 
  names(ones) <- 0:9 
  teens <- c("ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen",
             "sixteen", " seventeen", "eighteen", "nineteen")
  names(teens) <- 0:9 
  tens <- c("twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty",
            "ninety") 
  names(tens) <- 2:9 
  x <- round(x)
  suffixes <- c("thousand", "million", "billion", "trillion")     
  if (length(x) > 1) return(trim(sapply(x, helper)))
  helper(x)
}


nums = paste(numbers2words(1:1000),collapse="")
nums=gsub(" ","",nums)
nchar(nums)

# number pyramid
p=list(c(75),
c(95, 64),
c(17, 47, 82),
c(18, 35, 87, 10),
c(20, 04, 82, 47, 65),
c(19, 01, 23, 75, 03, 34),
c(88, 02, 77, 73, 07, 63, 67),
c(99, 65, 04, 28, 06, 16, 70, 92),
c(41, 41, 26, 56, 83, 40, 80, 70, 33),
c(41, 48, 72, 33, 47, 32, 37, 16, 94, 29),
c(53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14),
c(70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57),
c(91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48),
c(63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31),
c(04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23))

findpyr = function(p){
  tot = 75
  x = c(1,2)
  for (i in 2: length(p)){
    x = seq(which.max(p[[i]][x]),by=1,length.out = 2)
    tot = tot + max(p[[i]])
  }
  return(tot)
}

# circular primes
prmfind2 = function(z){
  z[z%%(2:(z-1))]
}
cirprimes = function(n){

}

a=as.character(1:1000)
b = sapply(a,function(x){x%in%stringi::stri_reverse(a[-as.numeric(x)])})

distinctprimes = function(n){
  i = 647
  while (1){
    Reduce(intersect,lapply(i:(i+3),function(x) prmfind2(x)))
  }
  
  
}
# unique

a = c(1,2,3,4,5,6,7,8,9,0)
b = 1:999999999
